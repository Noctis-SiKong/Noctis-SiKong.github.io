# 村村通问题

## 本质是求解**最小生成树（MST）** 问题，选择 Kruskal 算法

```java
import java.util.Arrays;
import java.util.Scanner;

// 定义边类，实现Comparable接口用于按权重排序
class Edge implements Comparable<Edge> {
    int u;          // 起点城镇
    int v;          // 终点城镇
    int weight;     // 改建成本

    public Edge(int u, int v, int weight) {
        this.u = u;
        this.v = v;
        this.weight = weight;
    }

    // 按权重升序排序
    @Override
    public int compareTo(Edge o) {
        return this.weight - o.weight;
    }
}

public class Main {
    private static int[] parent; // 并查集父节点数组

    // 查找根节点（带路径压缩，优化查询效率）
    private static int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 路径压缩：将节点直接指向根
        }
        return parent[x];
    }

    // 合并两个集合
    private static void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            parent[rootY] = rootX; // 将y的根节点指向x的根节点
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // 多组测试数据处理
        while (scanner.hasNextInt()) {
            int N = scanner.nextInt(); // 城镇数目
            int M = scanner.nextInt(); // 候选道路数目
            Edge[] edges = new Edge[M];

            // 读取所有候选道路
            for (int i = 0; i < M; i++) {
                int u = scanner.nextInt();
                int v = scanner.nextInt();
                int weight = scanner.nextInt();
                edges[i] = new Edge(u, v, weight);
            }

            // 按权重升序排序边
            Arrays.sort(edges);

            // 初始化并查集：每个城镇初始为自身的父节点
            parent = new int[N + 1]; // 城镇编号从1到N，索引0不用
            for (int i = 1; i <= N; i++) {
                parent[i] = i;
            }

            int selectedEdges = 0; // 已选边数（目标：N-1）
            int totalCost = 0;     // 最小总成本

            // 遍历排序后的边，贪心选边
            for (Edge edge : edges) {
                int rootU = find(edge.u);
                int rootV = find(edge.v);
                // 若两个城镇不属于同一集合，合并并累加成本
                if (rootU != rootV) {
                    union(rootU, rootV);
                    totalCost += edge.weight;
                    selectedEdges++;
                    // 选够N-1条边，提前终止
                    if (selectedEdges == N - 1) {
                        break;
                    }
                }
            }

            // 输出结果：选够N-1条边则输出总成本，否则输出-1
            if (selectedEdges == N - 1) {
                System.out.println(totalCost);
            } else {
                System.out.println(-1);
            }
        }
        scanner.close();
    }
}
```

